Design:
1.Both c++ functions and lua functions that are intended to be called from remote clients have to be registered first.
	<lua>
	Register : 
		reg.set('func_name', func, INTERGER, STRING, POINTVEC)	-- the result type is void
		ret.set_ret(INTEGER, 'func_name', func)	-- register a function which has a return value. INTEGER is the result type.

	Call a remote function:
		server.call('func_name', param1, param2)	-- 



2.Use proxy classes to simply the calling of remote functions.
3.A registered function can have a parameter of type IArchive to manually read the rest of the packet data.

	/** (it's wrong)
	Problem : if the library is intended to use template to support a variety of archive types, the function which would like to have a parameter of the input archive type must also be template function 

	Another solution : the input archive object can be got through some other ways rather than being passed in as a parameter.
	*/

4.Separates the C++ part and the lua part so that the users can get rid of the lua part if they don't need it.	The lua part can just be a plugin.

5.Network interface (input and output)
The rpc library should be independent of the network system.
Input(server):
Provides an input function which is to be called by the user when a new packet is received.

Output(client):
Provides a common network interface which the user should implement and pass in as a parameter.

Problem - whose responsibility is it to manage the buffers		-- IBufferManager

6.Concurrency
Server:
The concurrency of the server depends on whether the input function is called concurrently.

Client:



7.Some other issues:
	a) cancelling	-- it's useful when a user wants to cancel a task that is costly to perform (usually it will take a considerable time to perform). Apparently it's ignorable at the moment and the users can still implement it on a higher level.
	b) timeout : it will be supported.
	





////
1.ArchiveType
Defines input/output archive types used for serialization.

2.Server

	The user can provide a callback function to handle the calling of unregistered function. The default behavior is throwing an exception.

	reg	: register a function. This can be called at any time.

	input : called by the user to interpret a packet

	struct GetGame
	{
		typedef Game	type;
	
		template<class IArchive>
		type & get(ID client_id, IArhcive & ia)
		{
			return Game::instance();
		}
	};


3.Client
	call :  call a remote function.  The return value type is a private nested class of Client so that the user can not keep the return value or a reference/pointer to the return value directly. Instead, the user can throw away the return value or keep it in an object that the return value can be (implicitly) converted to. And the way the user deals with the return value will determine how the remote call will be performed. Here are all the ways:
		Acknowledgement - an acknowledgement will be sent back to indicate that the remote call has been executed.
		
		ReturningHandler - result of the remote function is required to be sent back


4. Exceptions
	
	Exceptions thrown by the remote function will be caught and transporting to the client. 	
	

5. Protocol
	
	An exception class is registered with its class name. And usually the users will also choose std::string type as the identifier type of the registered functions. To reduce bandwidth usage, we will send the unique hash code of these strings rather than sending the strings directly.
